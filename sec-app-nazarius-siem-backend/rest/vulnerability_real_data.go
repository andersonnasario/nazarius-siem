package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
)

// ============================================================================
// VULNERABILITY MANAGEMENT - REAL DATA HANDLERS
// ============================================================================
// These handlers fetch vulnerability data from OpenSearch (populated by AWS Inspector)
// and fall back to mock data if real data is not available

// handleGetVulnerabilityDashboardReal returns real vulnerability dashboard data
func (s *APIServer) handleGetVulnerabilityDashboardReal(c *gin.Context) {
	// Check OpenSearch availability for real data
	if s.opensearch == nil {
		log.Println("‚ö†Ô∏è OpenSearch not available, falling back to mock data")
		s.handleGetVulnerabilityDashboard(c)
		return
	}

	// Get statistics from OpenSearch
	stats, err := s.getVulnerabilityStatsFromOpenSearch()
	if err != nil {
		log.Printf("‚ö†Ô∏è Failed to get vulnerability stats: %v", err)
		s.handleGetVulnerabilityDashboard(c)
		return
	}

	// If no data in OpenSearch, fall back to mock data for demonstration
	if stats.TotalVulnerabilities == 0 && stats.CriticalVulns == 0 && stats.HighVulns == 0 {
		log.Println("‚ö†Ô∏è No vulnerability data in OpenSearch, falling back to mock data")
		s.handleGetVulnerabilityDashboard(c)
		return
	}

	// Get top vulnerabilities (critical and high severity)
	topVulns, err := s.getTopVulnerabilitiesFromOpenSearch(10)
	if err != nil {
		log.Printf("‚ö†Ô∏è Failed to get top vulnerabilities: %v", err)
		topVulns = []InspectorFinding{}
	}

	// Get top affected assets
	topAssets, err := s.getTopAffectedAssetsFromOpenSearch(10)
	if err != nil {
		log.Printf("‚ö†Ô∏è Failed to get top assets: %v", err)
		topAssets = []map[string]interface{}{}
	}

	// Get trends (last 7 days)
	trends, err := s.getVulnerabilityTrendsFromOpenSearch(7)
	if err != nil {
		log.Printf("‚ö†Ô∏è Failed to get trends: %v", err)
		trends = []VulnerabilityTrend{}
	}

	c.JSON(http.StatusOK, gin.H{
		"stats":               stats,
		"top_vulnerabilities": topVulns,
		"top_assets":          topAssets,
		"trends":              trends,
		"source":              "opensearch",
	})
}

// handleListVulnerabilitiesReal returns real vulnerability list
func (s *APIServer) handleListVulnerabilitiesReal(c *gin.Context) {
	// Check OpenSearch availability for real data
	if s.opensearch == nil {
		log.Println("‚ö†Ô∏è OpenSearch not available, falling back to mock data")
		s.handleListVulnerabilities(c)
		return
	}

	// Parse query parameters
	severity := c.Query("severity")
	status := c.Query("status")
	resourceType := c.Query("resource_type")
	cveID := c.Query("cve_id")
	search := c.Query("search")
	exploitable := c.Query("exploitable")
	fixAvailable := c.Query("fix_available")
	
	limitStr := c.DefaultQuery("limit", "50")
	offsetStr := c.DefaultQuery("offset", "0")
	sortBy := c.DefaultQuery("sort_by", "cvss_score")
	sortOrder := c.DefaultQuery("sort_order", "desc")

	limit, _ := strconv.Atoi(limitStr)
	offset, _ := strconv.Atoi(offsetStr)

	if limit <= 0 || limit > 500 {
		limit = 50
	}

	// Build OpenSearch query
	must := []map[string]interface{}{}

	if severity != "" {
		must = append(must, map[string]interface{}{
			"term": map[string]interface{}{"severity": strings.ToUpper(severity)},
		})
	}

	if status != "" {
		must = append(must, map[string]interface{}{
			"term": map[string]interface{}{"status": strings.ToUpper(status)},
		})
	}

	if resourceType != "" {
		must = append(must, map[string]interface{}{
			"term": map[string]interface{}{"resource_type": resourceType},
		})
	}

	if cveID != "" {
		must = append(must, map[string]interface{}{
			"term": map[string]interface{}{"cve_id": cveID},
		})
	}

	if exploitable == "true" {
		must = append(must, map[string]interface{}{
			"term": map[string]interface{}{"exploit_available": true},
		})
	}

	if fixAvailable == "true" {
		must = append(must, map[string]interface{}{
			"term": map[string]interface{}{"fix_available": true},
		})
	}

	if search != "" {
		must = append(must, map[string]interface{}{
			"multi_match": map[string]interface{}{
				"query":  search,
				"fields": []string{"title", "description", "cve_id", "vulnerable_package", "resource_id"},
			},
		})
	}

	query := map[string]interface{}{
		"size": limit,
		"from": offset,
		"sort": []map[string]interface{}{
			{sortBy: map[string]interface{}{"order": sortOrder}},
		},
	}

	if len(must) > 0 {
		query["query"] = map[string]interface{}{
			"bool": map[string]interface{}{"must": must},
		}
	} else {
		query["query"] = map[string]interface{}{
			"match_all": map[string]interface{}{},
		}
	}

	queryJSON, _ := json.Marshal(query)

	res, err := s.opensearch.Search(
		s.opensearch.Search.WithIndex("siem-vulnerabilities"),
		s.opensearch.Search.WithBody(strings.NewReader(string(queryJSON))),
	)
	if err != nil {
		log.Printf("‚ùå Vulnerability search failed: %v", err)
		s.handleListVulnerabilities(c)
		return
	}
	defer res.Body.Close()

	if res.IsError() {
		log.Printf("‚ùå OpenSearch error: %s", res.String())
		s.handleListVulnerabilities(c)
		return
	}

	var result map[string]interface{}
	json.NewDecoder(res.Body).Decode(&result)

	vulnerabilities := []InspectorFinding{}
	total := 0

	if hits, ok := result["hits"].(map[string]interface{}); ok {
		if totalVal, ok := hits["total"].(map[string]interface{}); ok {
			if val, ok := totalVal["value"].(float64); ok {
				total = int(val)
			}
		}

		if hitsArr, ok := hits["hits"].([]interface{}); ok {
			for _, h := range hitsArr {
				hit := h.(map[string]interface{})
				source := hit["_source"].(map[string]interface{})

				finding := parseInspectorFinding(source)
				vulnerabilities = append(vulnerabilities, finding)
			}
		}
	}

	// If no data from OpenSearch, fall back to mock data for demonstration
	if len(vulnerabilities) == 0 && total == 0 {
		log.Println("‚ö†Ô∏è No vulnerability data in OpenSearch, falling back to mock data")
		s.handleListVulnerabilities(c)
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"vulnerabilities": vulnerabilities,
		"total":           total,
		"limit":           limit,
		"offset":          offset,
		"source":          "opensearch",
	})
}

// handleGetVulnerabilityReal returns a single vulnerability by ID
func (s *APIServer) handleGetVulnerabilityReal(c *gin.Context) {
	if s.opensearch == nil {
		s.handleGetVulnerability(c)
		return
	}

	vulnID := c.Param("id")

	query := map[string]interface{}{
		"query": map[string]interface{}{
			"bool": map[string]interface{}{
				"should": []map[string]interface{}{
					{"term": map[string]interface{}{"id": vulnID}},
					{"term": map[string]interface{}{"cve_id": vulnID}},
				},
				"minimum_should_match": 1,
			},
		},
	}

	queryJSON, _ := json.Marshal(query)

	res, err := s.opensearch.Search(
		s.opensearch.Search.WithIndex("siem-vulnerabilities"),
		s.opensearch.Search.WithBody(strings.NewReader(string(queryJSON))),
	)
	if err != nil {
		log.Printf("‚ùå Get vulnerability failed: %v", err)
		c.JSON(http.StatusNotFound, gin.H{"error": "Vulnerability not found"})
		return
	}
	defer res.Body.Close()

	var result map[string]interface{}
	json.NewDecoder(res.Body).Decode(&result)

	if hits, ok := result["hits"].(map[string]interface{}); ok {
		if hitsArr, ok := hits["hits"].([]interface{}); ok && len(hitsArr) > 0 {
			hit := hitsArr[0].(map[string]interface{})
			source := hit["_source"].(map[string]interface{})
			finding := parseInspectorFinding(source)

			// Get related findings for the same CVE
			relatedFindings := []InspectorFinding{}
			if finding.CVEID != "" {
				related, _ := s.getRelatedFindingsForCVE(finding.CVEID, finding.ID)
				relatedFindings = related
			}

			c.JSON(http.StatusOK, gin.H{
				"vulnerability":     finding,
				"related_findings":  relatedFindings,
				"source":            "opensearch",
			})
			return
		}
	}

	c.JSON(http.StatusNotFound, gin.H{"error": "Vulnerability not found"})
}

// handleListVulnerableAssetsReal returns affected assets with real data
func (s *APIServer) handleListVulnerableAssetsReal(c *gin.Context) {
	if s.opensearch == nil {
		s.handleListVulnerableAssets(c)
		return
	}

	// Aggregate by resource_id to get unique assets
	query := map[string]interface{}{
		"size": 0,
		"aggs": map[string]interface{}{
			"assets": map[string]interface{}{
				"terms": map[string]interface{}{
					"field": "resource_id",
					"size":  100,
				},
				"aggs": map[string]interface{}{
					"resource_type": map[string]interface{}{
						"terms": map[string]interface{}{
							"field": "resource_type",
							"size":  1,
						},
					},
					"severities": map[string]interface{}{
						"terms": map[string]interface{}{
							"field": "severity",
							"size":  5,
						},
					},
					"max_cvss": map[string]interface{}{
						"max": map[string]interface{}{
							"field": "cvss_score",
						},
					},
					"vulnerable_packages": map[string]interface{}{
						"terms": map[string]interface{}{
							"field": "vulnerable_package",
							"size":  5,
						},
					},
					"latest_finding": map[string]interface{}{
						"top_hits": map[string]interface{}{
							"size": 1,
							"sort": []map[string]interface{}{
								{"cvss_score": map[string]interface{}{"order": "desc"}},
							},
							"_source": []string{
								"instance_id", "platform", "account_id", "region",
								"vulnerable_package", "title", "cve_id", "hostname",
								"resource_name", "service_name", "ami_id", "tags",
							},
						},
					},
				},
			},
		},
	}

	queryJSON, _ := json.Marshal(query)

	res, err := s.opensearch.Search(
		s.opensearch.Search.WithIndex("siem-vulnerabilities"),
		s.opensearch.Search.WithBody(strings.NewReader(string(queryJSON))),
	)
	if err != nil {
		log.Printf("‚ùå Asset aggregation failed: %v", err)
		s.handleListVulnerableAssets(c)
		return
	}
	defer res.Body.Close()

	var result map[string]interface{}
	json.NewDecoder(res.Body).Decode(&result)

	assets := []map[string]interface{}{}

	if aggs, ok := result["aggregations"].(map[string]interface{}); ok {
		if assetsAgg, ok := aggs["assets"].(map[string]interface{}); ok {
			if buckets, ok := assetsAgg["buckets"].([]interface{}); ok {
				for _, b := range buckets {
					bucket := b.(map[string]interface{})
					resourceID := bucket["key"].(string)
					docCount := int(bucket["doc_count"].(float64))

					asset := map[string]interface{}{
						"id":                  resourceID,
						"resource_id":         resourceID,
						"vulnerability_count": docCount,
						"critical_vulns":      0,
						"high_vulns":          0,
						"medium_vulns":        0,
						"low_vulns":           0,
					}

					// Get resource type
					if rtAgg, ok := bucket["resource_type"].(map[string]interface{}); ok {
						if rtBuckets, ok := rtAgg["buckets"].([]interface{}); ok && len(rtBuckets) > 0 {
							rtBucket := rtBuckets[0].(map[string]interface{})
							asset["resource_type"] = rtBucket["key"].(string)
						}
					}

					// Get severity counts
					if sevAgg, ok := bucket["severities"].(map[string]interface{}); ok {
						if sevBuckets, ok := sevAgg["buckets"].([]interface{}); ok {
							for _, sb := range sevBuckets {
								sevBucket := sb.(map[string]interface{})
								severity := sevBucket["key"].(string)
								count := int(sevBucket["doc_count"].(float64))

								switch strings.ToUpper(severity) {
								case "CRITICAL":
									asset["critical_vulns"] = count
								case "HIGH":
									asset["high_vulns"] = count
								case "MEDIUM":
									asset["medium_vulns"] = count
								case "LOW":
									asset["low_vulns"] = count
								}
							}
						}
					}

					// Get max CVSS score
					if maxCVSS, ok := bucket["max_cvss"].(map[string]interface{}); ok {
						if val, ok := maxCVSS["value"].(float64); ok {
							asset["risk_score"] = val * 10 // Convert 0-10 to 0-100
						}
					}

					// Get vulnerable packages list
					vulnerablePackages := []string{}
					if vpAgg, ok := bucket["vulnerable_packages"].(map[string]interface{}); ok {
						if vpBuckets, ok := vpAgg["buckets"].([]interface{}); ok {
							for _, vp := range vpBuckets {
								vpBucket := vp.(map[string]interface{})
								if pkg, ok := vpBucket["key"].(string); ok && pkg != "" {
									vulnerablePackages = append(vulnerablePackages, pkg)
								}
							}
						}
					}
					asset["vulnerable_packages"] = vulnerablePackages

					// Get latest finding details
					if latestHits, ok := bucket["latest_finding"].(map[string]interface{}); ok {
						if hits, ok := latestHits["hits"].(map[string]interface{}); ok {
							if hitsArr, ok := hits["hits"].([]interface{}); ok && len(hitsArr) > 0 {
								hit := hitsArr[0].(map[string]interface{})
								source := hit["_source"].(map[string]interface{})
								
								if instanceID, ok := source["instance_id"].(string); ok {
									asset["instance_id"] = instanceID
								}
								if platform, ok := source["platform"].(string); ok {
									asset["platform"] = platform
								}
								if accountID, ok := source["account_id"].(string); ok {
									asset["account_id"] = accountID
								}
								if region, ok := source["region"].(string); ok {
									asset["region"] = region
								}
								if hostname, ok := source["hostname"].(string); ok {
									asset["hostname"] = hostname
								}
								if resourceName, ok := source["resource_name"].(string); ok {
									asset["resource_name"] = resourceName
								}
								if serviceName, ok := source["service_name"].(string); ok {
									asset["service_name"] = serviceName
								}
								if amiID, ok := source["ami_id"].(string); ok {
									asset["ami_id"] = amiID
								}
								if vulnPkg, ok := source["vulnerable_package"].(string); ok {
									asset["top_vulnerable_package"] = vulnPkg
								}
								if title, ok := source["title"].(string); ok {
									asset["top_vulnerability_title"] = title
								}
								if cveID, ok := source["cve_id"].(string); ok {
									asset["top_cve_id"] = cveID
								}
								// Extract tags if available
								if tags, ok := source["tags"].(map[string]interface{}); ok {
									if name, ok := tags["Name"].(string); ok {
										asset["name"] = name
									}
								}
							}
						}
					}

					// Generate a friendly display name
					displayName := ""
					if name, ok := asset["name"].(string); ok && name != "" {
						displayName = name
					} else if hostname, ok := asset["hostname"].(string); ok && hostname != "" {
						displayName = hostname
					} else if instanceID, ok := asset["instance_id"].(string); ok && instanceID != "" {
						displayName = instanceID
					} else {
						// Extract instance ID from ARN
						if strings.Contains(resourceID, "instance/") {
							parts := strings.Split(resourceID, "instance/")
							if len(parts) > 1 {
								displayName = parts[1]
							}
						}
					}
					asset["display_name"] = displayName

					assets = append(assets, asset)
				}
			}
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"assets": assets,
		"total":  len(assets),
		"source": "opensearch",
	})
}

// handleGetVulnerableAssetReal returns a specific asset with its vulnerabilities
func (s *APIServer) handleGetVulnerableAssetReal(c *gin.Context) {
	assetID := c.Param("id")
	
	if s.opensearch == nil {
		s.handleGetVulnerableAsset(c)
		return
	}

	log.Printf("üîç Looking for asset vulnerabilities: %s", assetID)

	// Decode URL-encoded asset ID (ARNs contain special characters)
	decodedID := assetID
	// URL decode if needed
	if strings.Contains(assetID, "%") {
		if decoded, err := url.QueryUnescape(assetID); err == nil {
			decodedID = decoded
		}
	}

	log.Printf("üîç Decoded asset ID: %s", decodedID)

	// Extract instance ID from ARN if present (e.g., arn:aws:ec2:...:instance/i-xxx -> i-xxx)
	// Also handle if just the instance ID is passed directly
	instanceID := decodedID
	if strings.Contains(decodedID, "instance/") {
		parts := strings.Split(decodedID, "instance/")
		if len(parts) > 1 {
			instanceID = parts[1]
		}
	}
	
	// If the ID starts with i- it's likely already an instance ID
	if strings.HasPrefix(decodedID, "i-") {
		instanceID = decodedID
	}
	
	log.Printf("üîç Using instance ID for search: %s", instanceID)

	// Build search query optimized for instance ID lookup
	// Primary strategy: search by instance_id field (most reliable)
	query := map[string]interface{}{
		"query": map[string]interface{}{
			"bool": map[string]interface{}{
				"should": []map[string]interface{}{
					// Strategy 1: Exact match on instance_id (most likely to work)
					{
						"term": map[string]interface{}{
							"instance_id.keyword": instanceID,
						},
					},
					// Strategy 2: Match on instance_id without keyword
					{
						"match": map[string]interface{}{
							"instance_id": instanceID,
						},
					},
					// Strategy 3: Wildcard on resource_id containing the instance ID
					{
						"wildcard": map[string]interface{}{
							"resource_id.keyword": map[string]interface{}{
								"value": "*" + instanceID + "*",
							},
						},
					},
					// Strategy 4: Wildcard on resource_id without keyword
					{
						"wildcard": map[string]interface{}{
							"resource_id": map[string]interface{}{
								"value": "*" + instanceID + "*",
							},
						},
					},
				},
				"minimum_should_match": 1,
			},
		},
		"size": 500,
		"sort": []map[string]interface{}{
			{"cvss_score": map[string]interface{}{"order": "desc"}},
		},
	}

	queryJSON, _ := json.Marshal(query)
	log.Printf("üîç OpenSearch query: %s", string(queryJSON))

	res, err := s.opensearch.Search(
		s.opensearch.Search.WithIndex("siem-vulnerabilities"),
		s.opensearch.Search.WithBody(strings.NewReader(string(queryJSON))),
	)
	if err != nil {
		log.Printf("‚ùå Asset lookup failed: %v", err)
		s.handleGetVulnerableAsset(c)
		return
	}
	defer res.Body.Close()

	if res.IsError() {
		log.Printf("‚ùå OpenSearch error: %s", res.String())
		s.handleGetVulnerableAsset(c)
		return
	}

	var result map[string]interface{}
	json.NewDecoder(res.Body).Decode(&result)

	vulnerabilities := []map[string]interface{}{}
	var assetInfo map[string]interface{}
	totalVulns := 0
	criticalCount := 0
	highCount := 0
	mediumCount := 0
	lowCount := 0
	maxCVSS := 0.0

	// Log result for debugging
	if hits, ok := result["hits"].(map[string]interface{}); ok {
		if total, ok := hits["total"].(map[string]interface{}); ok {
			log.Printf("üìä Asset %s: Found %v vulnerabilities", assetID, total["value"])
		}
	}

	if hits, ok := result["hits"].(map[string]interface{}); ok {
		if totalVal, ok := hits["total"].(map[string]interface{}); ok {
			if val, ok := totalVal["value"].(float64); ok {
				totalVulns = int(val)
			}
		}

		if hitsArr, ok := hits["hits"].([]interface{}); ok {
			for i, h := range hitsArr {
				hit := h.(map[string]interface{})
				source := hit["_source"].(map[string]interface{})

				// Get asset info from first hit
				if i == 0 {
					assetInfo = map[string]interface{}{
						"id":            assetID,
						"resource_id":   getString(source, "resource_id"),
						"resource_type": getString(source, "resource_type"),
						"region":        getString(source, "region"),
						"account_id":    getString(source, "account_id"),
						"instance_id":   getString(source, "instance_id"),
						"platform":      getString(source, "platform"),
					}
				}

				// Count severities
				severity := strings.ToUpper(getString(source, "severity"))
				switch severity {
				case "CRITICAL":
					criticalCount++
				case "HIGH":
					highCount++
				case "MEDIUM":
					mediumCount++
				case "LOW":
					lowCount++
				}

				// Track max CVSS
				if cvss, ok := source["cvss_score"].(float64); ok && cvss > maxCVSS {
					maxCVSS = cvss
				}

				// Add vulnerability
				vuln := map[string]interface{}{
					"id":                 getString(source, "id"),
					"title":              getString(source, "title"),
					"cve_id":             getString(source, "cve_id"),
					"cvss_score":         source["cvss_score"],
					"severity":           severity,
					"status":             getString(source, "status"),
					"vulnerable_package": getString(source, "vulnerable_package"),
					"package_version":    getString(source, "package_version"),
					"fixed_version":      getString(source, "fixed_version"),
					"fix_available":      source["fix_available"],
					"exploit_available":  source["exploit_available"],
					"description":        getString(source, "description"),
					"first_observed_at":  source["first_observed_at"],
					"last_observed_at":   source["last_observed_at"],
				}
				vulnerabilities = append(vulnerabilities, vuln)
			}
		}
	}

	// If no data found, fall back to mock
	if totalVulns == 0 {
		s.handleGetVulnerableAsset(c)
		return
	}

	// Add stats to asset info
	if assetInfo != nil {
		assetInfo["vulnerability_count"] = totalVulns
		assetInfo["critical_vulns"] = criticalCount
		assetInfo["high_vulns"] = highCount
		assetInfo["medium_vulns"] = mediumCount
		assetInfo["low_vulns"] = lowCount
		assetInfo["risk_score"] = maxCVSS * 10
	}

	// Return in format expected by frontend
	c.JSON(http.StatusOK, gin.H{
		"asset":           assetInfo,
		"vulnerabilities": vulnerabilities,
		"total":           totalVulns,
		"source":          "opensearch",
	})
}

// handleGetVulnerabilityStatsReal returns real-time vulnerability statistics
func (s *APIServer) handleGetVulnerabilityStatsReal(c *gin.Context) {
	if s.opensearch == nil {
		s.handleGetVulnerabilityStats(c)
		return
	}

	stats, err := s.getVulnerabilityStatsFromOpenSearch()
	if err != nil {
		log.Printf("‚ö†Ô∏è Failed to get stats: %v", err)
		s.handleGetVulnerabilityStats(c)
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"stats":  stats,
		"source": "opensearch",
	})
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

func (s *APIServer) getVulnerabilityStatsFromOpenSearch() (VulnerabilityStats, error) {
	query := map[string]interface{}{
		"size": 0,
		"aggs": map[string]interface{}{
			"by_severity": map[string]interface{}{
				"terms": map[string]interface{}{
					"field": "severity",
					"size":  10,
				},
			},
			"by_status": map[string]interface{}{
				"terms": map[string]interface{}{
					"field": "status",
					"size":  10,
				},
			},
			"affected_resources": map[string]interface{}{
				"cardinality": map[string]interface{}{
					"field": "resource_id",
				},
			},
			"exploitable": map[string]interface{}{
				"filter": map[string]interface{}{
					"term": map[string]interface{}{"exploit_available": true},
				},
			},
			"with_fix": map[string]interface{}{
				"filter": map[string]interface{}{
					"term": map[string]interface{}{"fix_available": true},
				},
			},
			"latest_scan": map[string]interface{}{
				"max": map[string]interface{}{
					"field": "indexed_at",
				},
			},
		},
	}

	queryJSON, _ := json.Marshal(query)

	res, err := s.opensearch.Search(
		s.opensearch.Search.WithIndex("siem-vulnerabilities"),
		s.opensearch.Search.WithBody(strings.NewReader(string(queryJSON))),
	)
	if err != nil {
		return VulnerabilityStats{}, err
	}
	defer res.Body.Close()

	var result map[string]interface{}
	json.NewDecoder(res.Body).Decode(&result)

	stats := VulnerabilityStats{
		LastScanDate:      time.Now(),
		NextScheduledScan: time.Now().Add(24 * time.Hour),
	}

	if hits, ok := result["hits"].(map[string]interface{}); ok {
		if total, ok := hits["total"].(map[string]interface{}); ok {
			if val, ok := total["value"].(float64); ok {
				stats.TotalVulnerabilities = int(val)
			}
		}
	}

	if aggs, ok := result["aggregations"].(map[string]interface{}); ok {
		// Severity counts
		if sevAgg, ok := aggs["by_severity"].(map[string]interface{}); ok {
			if buckets, ok := sevAgg["buckets"].([]interface{}); ok {
				for _, b := range buckets {
					bucket := b.(map[string]interface{})
					severity := bucket["key"].(string)
					count := int(bucket["doc_count"].(float64))

					switch strings.ToUpper(severity) {
					case "CRITICAL":
						stats.CriticalVulns = count
					case "HIGH":
						stats.HighVulns = count
					case "MEDIUM":
						stats.MediumVulns = count
					case "LOW":
						stats.LowVulns = count
					}
				}
			}
		}

		// Status counts
		if statusAgg, ok := aggs["by_status"].(map[string]interface{}); ok {
			if buckets, ok := statusAgg["buckets"].([]interface{}); ok {
				for _, b := range buckets {
					bucket := b.(map[string]interface{})
					status := bucket["key"].(string)
					count := int(bucket["doc_count"].(float64))

					switch strings.ToUpper(status) {
					case "ACTIVE", "OPEN", "NEW":
						stats.OpenVulns += count
					case "CLOSED", "FIXED", "RESOLVED":
						stats.PatchedVulns += count
					case "SUPPRESSED", "IN_PROGRESS", "NOTIFIED":
						stats.InProgressVulns += count
					}
				}
			}
		}

		// Affected resources
		if affectedAgg, ok := aggs["affected_resources"].(map[string]interface{}); ok {
			if val, ok := affectedAgg["value"].(float64); ok {
				stats.VulnerableAssets = int(val)
				stats.TotalAssets = int(val) // Approximate
			}
		}

		// Assets with critical vulns
		stats.AssetsWithCritical = stats.CriticalVulns / 3 // Approximate

		// Patch compliance
		if stats.TotalVulnerabilities > 0 {
			stats.PatchCompliance = float64(stats.PatchedVulns) / float64(stats.TotalVulnerabilities) * 100
		}

		// Latest scan
		if latestAgg, ok := aggs["latest_scan"].(map[string]interface{}); ok {
			if valStr, ok := latestAgg["value_as_string"].(string); ok {
				if t, err := time.Parse(time.RFC3339, valStr); err == nil {
					stats.LastScanDate = t
				}
			}
		}
	}

	return stats, nil
}

func (s *APIServer) getTopVulnerabilitiesFromOpenSearch(limit int) ([]InspectorFinding, error) {
	query := map[string]interface{}{
		"size": limit,
		"sort": []map[string]interface{}{
			{"cvss_score": map[string]interface{}{"order": "desc"}},
			{"exploit_available": map[string]interface{}{"order": "desc"}},
		},
		"query": map[string]interface{}{
			"bool": map[string]interface{}{
				"should": []map[string]interface{}{
					{"term": map[string]interface{}{"severity": "CRITICAL"}},
					{"term": map[string]interface{}{"severity": "HIGH"}},
				},
				"minimum_should_match": 1,
			},
		},
	}

	queryJSON, _ := json.Marshal(query)

	res, err := s.opensearch.Search(
		s.opensearch.Search.WithIndex("siem-vulnerabilities"),
		s.opensearch.Search.WithBody(strings.NewReader(string(queryJSON))),
	)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	var result map[string]interface{}
	json.NewDecoder(res.Body).Decode(&result)

	findings := []InspectorFinding{}

	if hits, ok := result["hits"].(map[string]interface{}); ok {
		if hitsArr, ok := hits["hits"].([]interface{}); ok {
			for _, h := range hitsArr {
				hit := h.(map[string]interface{})
				source := hit["_source"].(map[string]interface{})
				findings = append(findings, parseInspectorFinding(source))
			}
		}
	}

	return findings, nil
}

func (s *APIServer) getTopAffectedAssetsFromOpenSearch(limit int) ([]map[string]interface{}, error) {
	query := map[string]interface{}{
		"size": 0,
		"aggs": map[string]interface{}{
			"top_assets": map[string]interface{}{
				"terms": map[string]interface{}{
					"field": "resource_id",
					"size":  limit,
					"order": map[string]interface{}{
						"max_cvss": "desc",
					},
				},
				"aggs": map[string]interface{}{
					"max_cvss": map[string]interface{}{
						"max": map[string]interface{}{
							"field": "cvss_score",
						},
					},
					"critical_count": map[string]interface{}{
						"filter": map[string]interface{}{
							"term": map[string]interface{}{"severity": "CRITICAL"},
						},
					},
				},
			},
		},
	}

	queryJSON, _ := json.Marshal(query)

	res, err := s.opensearch.Search(
		s.opensearch.Search.WithIndex("siem-vulnerabilities"),
		s.opensearch.Search.WithBody(strings.NewReader(string(queryJSON))),
	)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	var result map[string]interface{}
	json.NewDecoder(res.Body).Decode(&result)

	assets := []map[string]interface{}{}

	if aggs, ok := result["aggregations"].(map[string]interface{}); ok {
		if topAssets, ok := aggs["top_assets"].(map[string]interface{}); ok {
			if buckets, ok := topAssets["buckets"].([]interface{}); ok {
				for _, b := range buckets {
					bucket := b.(map[string]interface{})
					asset := map[string]interface{}{
						"resource_id":         bucket["key"].(string),
						"vulnerability_count": int(bucket["doc_count"].(float64)),
					}

					if maxCVSS, ok := bucket["max_cvss"].(map[string]interface{}); ok {
						if val, ok := maxCVSS["value"].(float64); ok {
							asset["max_cvss"] = val
							asset["risk_score"] = val * 10
						}
					}

					if criticalAgg, ok := bucket["critical_count"].(map[string]interface{}); ok {
						if count, ok := criticalAgg["doc_count"].(float64); ok {
							asset["critical_vulns"] = int(count)
						}
					}

					assets = append(assets, asset)
				}
			}
		}
	}

	return assets, nil
}

func (s *APIServer) getVulnerabilityTrendsFromOpenSearch(days int) ([]VulnerabilityTrend, error) {
	query := map[string]interface{}{
		"size": 0,
		"query": map[string]interface{}{
			"range": map[string]interface{}{
				"first_observed_at": map[string]interface{}{
					"gte": fmt.Sprintf("now-%dd/d", days),
				},
			},
		},
		"aggs": map[string]interface{}{
			"daily": map[string]interface{}{
				"date_histogram": map[string]interface{}{
					"field":             "first_observed_at",
					"calendar_interval": "day",
				},
				"aggs": map[string]interface{}{
					"by_severity": map[string]interface{}{
						"terms": map[string]interface{}{
							"field": "severity",
						},
					},
				},
			},
		},
	}

	queryJSON, _ := json.Marshal(query)

	res, err := s.opensearch.Search(
		s.opensearch.Search.WithIndex("siem-vulnerabilities"),
		s.opensearch.Search.WithBody(strings.NewReader(string(queryJSON))),
	)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	var result map[string]interface{}
	json.NewDecoder(res.Body).Decode(&result)

	trends := []VulnerabilityTrend{}

	if aggs, ok := result["aggregations"].(map[string]interface{}); ok {
		if daily, ok := aggs["daily"].(map[string]interface{}); ok {
			if buckets, ok := daily["buckets"].([]interface{}); ok {
				for _, b := range buckets {
					bucket := b.(map[string]interface{})
					
					dateStr := bucket["key_as_string"].(string)
					total := int(bucket["doc_count"].(float64))

					trend := VulnerabilityTrend{
						Date:  dateStr[:10], // YYYY-MM-DD
						Total: total,
					}

					if sevAgg, ok := bucket["by_severity"].(map[string]interface{}); ok {
						if sevBuckets, ok := sevAgg["buckets"].([]interface{}); ok {
							for _, sb := range sevBuckets {
								sevBucket := sb.(map[string]interface{})
								severity := sevBucket["key"].(string)
								count := int(sevBucket["doc_count"].(float64))

								switch strings.ToUpper(severity) {
								case "CRITICAL":
									trend.Critical = count
								case "HIGH":
									trend.High = count
								case "MEDIUM":
									trend.Medium = count
								case "LOW":
									trend.Low = count
								}
							}
						}
					}

					trends = append(trends, trend)
				}
			}
		}
	}

	return trends, nil
}

func (s *APIServer) getRelatedFindingsForCVE(cveID string, excludeID string) ([]InspectorFinding, error) {
	query := map[string]interface{}{
		"size": 10,
		"query": map[string]interface{}{
			"bool": map[string]interface{}{
				"must": []map[string]interface{}{
					{"term": map[string]interface{}{"cve_id": cveID}},
				},
				"must_not": []map[string]interface{}{
					{"term": map[string]interface{}{"id": excludeID}},
				},
			},
		},
	}

	queryJSON, _ := json.Marshal(query)

	res, err := s.opensearch.Search(
		s.opensearch.Search.WithIndex("siem-vulnerabilities"),
		s.opensearch.Search.WithBody(strings.NewReader(string(queryJSON))),
	)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	var result map[string]interface{}
	json.NewDecoder(res.Body).Decode(&result)

	findings := []InspectorFinding{}

	if hits, ok := result["hits"].(map[string]interface{}); ok {
		if hitsArr, ok := hits["hits"].([]interface{}); ok {
			for _, h := range hitsArr {
				hit := h.(map[string]interface{})
				source := hit["_source"].(map[string]interface{})
				findings = append(findings, parseInspectorFinding(source))
			}
		}
	}

	return findings, nil
}

// parseInspectorFinding converts OpenSearch document to InspectorFinding
func parseInspectorFinding(source map[string]interface{}) InspectorFinding {
	f := InspectorFinding{
		Source: "AWS Inspector",
	}

	if v, ok := source["id"].(string); ok {
		f.ID = v
	}
	if v, ok := source["finding_arn"].(string); ok {
		f.FindingARN = v
	}
	if v, ok := source["type"].(string); ok {
		f.Type = v
	}
	if v, ok := source["title"].(string); ok {
		f.Title = v
	}
	if v, ok := source["description"].(string); ok {
		f.Description = v
	}
	if v, ok := source["severity"].(string); ok {
		f.Severity = v
	}
	if v, ok := source["status"].(string); ok {
		f.Status = v
	}
	if v, ok := source["cve_id"].(string); ok {
		f.CVEID = v
	}
	if v, ok := source["cvss_score"].(float64); ok {
		f.CVSSScore = v
	}
	if v, ok := source["cvss_vector"].(string); ok {
		f.CVSSVector = v
	}
	if v, ok := source["exploit_available"].(bool); ok {
		f.ExploitAvailable = v
	}
	if v, ok := source["fix_available"].(bool); ok {
		f.FixAvailable = v
	}
	if v, ok := source["resource_type"].(string); ok {
		f.ResourceType = v
	}
	if v, ok := source["resource_id"].(string); ok {
		f.ResourceID = v
	}
	if v, ok := source["resource_arn"].(string); ok {
		f.ResourceARN = v
	}
	if v, ok := source["instance_id"].(string); ok {
		f.InstanceID = v
	}
	if v, ok := source["instance_type"].(string); ok {
		f.InstanceType = v
	}
	if v, ok := source["platform"].(string); ok {
		f.Platform = v
	}
	if v, ok := source["image_digest"].(string); ok {
		f.ImageDigest = v
	}
	if v, ok := source["image_repository"].(string); ok {
		f.ImageRepository = v
	}
	if v, ok := source["function_name"].(string); ok {
		f.FunctionName = v
	}
	if v, ok := source["runtime"].(string); ok {
		f.Runtime = v
	}
	if v, ok := source["vulnerable_package"].(string); ok {
		f.VulnerablePackage = v
	}
	if v, ok := source["package_version"].(string); ok {
		f.PackageVersion = v
	}
	if v, ok := source["fixed_version"].(string); ok {
		f.FixedVersion = v
	}
	if v, ok := source["package_manager"].(string); ok {
		f.PackageManager = v
	}
	if v, ok := source["account_id"].(string); ok {
		f.AccountID = v
	}
	if v, ok := source["region"].(string); ok {
		f.Region = v
	}

	// Parse timestamps
	if v, ok := source["first_observed_at"].(string); ok {
		if t, err := time.Parse(time.RFC3339, v); err == nil {
			f.FirstObservedAt = t
		}
	}
	if v, ok := source["last_observed_at"].(string); ok {
		if t, err := time.Parse(time.RFC3339, v); err == nil {
			f.LastObservedAt = t
		}
	}
	if v, ok := source["timestamp"].(string); ok {
		if t, err := time.Parse(time.RFC3339, v); err == nil {
			f.Timestamp = t
		}
	}

	return f
}

// ============================================================================
// SCAN / COVERAGE HANDLERS - REAL DATA FROM AWS INSPECTOR
// ============================================================================

// InspectorCoverage represents Inspector coverage status
type InspectorCoverage struct {
	ID              string    `json:"id"`
	Name            string    `json:"name"`
	Type            string    `json:"type"`     // full, continuous
	Status          string    `json:"status"`   // running, completed
	AssetsScanned   int       `json:"assets"`
	Vulnerabilities int       `json:"vulnerabilities"`
	Critical        int       `json:"critical"`
	StartedAt       time.Time `json:"started_at"`
	Duration        string    `json:"duration"`
	InitiatedBy     string    `json:"initiated_by"`
}

// handleListScansReal returns real scan/coverage data from AWS Inspector
func (s *APIServer) handleListScansReal(c *gin.Context) {
	if s.opensearch == nil {
		s.handleListScans(c)
		return
	}

	// Get coverage statistics from OpenSearch
	// Inspector v2 does continuous scanning, so we show coverage periods
	
	// Get distinct days with findings to simulate "scans"
	// Try multiple date fields that might exist in the data
	query := map[string]interface{}{
		"size": 0,
		"aggs": map[string]interface{}{
			"scans_by_day": map[string]interface{}{
				"date_histogram": map[string]interface{}{
					"field":             "last_observed_at",
					"calendar_interval": "day",
					"format":            "yyyy-MM-dd",
					"order":             map[string]string{"_key": "desc"},
					"min_doc_count":     1,
				},
				"aggs": map[string]interface{}{
					"total_vulns": map[string]interface{}{
						"value_count": map[string]interface{}{
							"field": "cve_id.keyword",
						},
					},
					"critical": map[string]interface{}{
						"filter": map[string]interface{}{
							"term": map[string]interface{}{"severity.keyword": "CRITICAL"},
						},
					},
					"high": map[string]interface{}{
						"filter": map[string]interface{}{
							"term": map[string]interface{}{"severity.keyword": "HIGH"},
						},
					},
					"unique_assets": map[string]interface{}{
						"cardinality": map[string]interface{}{
							"field": "resource_id.keyword",
						},
					},
				},
			},
		},
	}

	log.Printf("üîç Querying scans from OpenSearch...")
	result, err := s.executeOpenSearchQuery("siem-vulnerabilities", query)
	if err != nil {
		log.Printf("‚ö†Ô∏è Failed to get scan data: %v", err)
		s.handleListScans(c)
		return
	}

	// Parse aggregation results
	scans := []InspectorCoverage{}
	
	if aggs, ok := result["aggregations"].(map[string]interface{}); ok {
		if scansByDay, ok := aggs["scans_by_day"].(map[string]interface{}); ok {
			if buckets, ok := scansByDay["buckets"].([]interface{}); ok {
				for i, bucket := range buckets {
					if i >= 10 { // Limit to last 10 "scans"
						break
					}
					b := bucket.(map[string]interface{})
					
					dateStr := b["key_as_string"].(string)
					date, _ := time.Parse("2006-01-02", dateStr)
					
					totalVulns := 0
					if tv, ok := b["total_vulns"].(map[string]interface{}); ok {
						totalVulns = int(tv["value"].(float64))
					}
					
					criticalCount := 0
					if crit, ok := b["critical"].(map[string]interface{}); ok {
						criticalCount = int(crit["doc_count"].(float64))
					}
					
					uniqueAssets := 0
					if ua, ok := b["unique_assets"].(map[string]interface{}); ok {
						uniqueAssets = int(ua["value"].(float64))
					}
					
					// Determine status based on date
				status := "completed"
				scanName := fmt.Sprintf("Inspector Continuous Scan - %s", dateStr)
				duration := "24h"
				
				today := time.Now().Format("2006-01-02")
				yesterday := time.Now().AddDate(0, 0, -1).Format("2006-01-02")
				
				if dateStr == today {
					// Today - still collecting data
					status = "running"
					scanName = "Inspector Continuous Scan - Today"
					// Calculate hours since midnight
					now := time.Now()
					midnight := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, now.Location())
					hoursElapsed := int(now.Sub(midnight).Hours())
					duration = fmt.Sprintf("%dh (em andamento)", hoursElapsed)
				} else if dateStr == yesterday {
					scanName = "Inspector Continuous Scan - Yesterday"
				}
				
				scan := InspectorCoverage{
					ID:              fmt.Sprintf("inspector-%s", dateStr),
					Name:            scanName,
					Type:            "continuous",
					Status:          status,
					AssetsScanned:   uniqueAssets,
					Vulnerabilities: totalVulns,
					Critical:        criticalCount,
					StartedAt:       date,
					Duration:        duration,
					InitiatedBy:     "AWS Inspector (Continuous)",
				}
					
				scans = append(scans, scan)
				}
			}
		}
	}

	// If no data from OpenSearch, fall back to mock data
	if len(scans) == 0 {
		log.Println("‚ö†Ô∏è No vulnerability data in OpenSearch, falling back to mock data")
		s.handleListScans(c)
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"scans":  scans,
		"total":  len(scans),
		"source": "aws-inspector",
		"note":   "AWS Inspector v2 performs continuous scanning. These entries represent daily scan summaries.",
	})
}

// handleGetScanReal returns details of a specific scan period
func (s *APIServer) handleGetScanReal(c *gin.Context) {
	scanID := c.Param("id")
	
	if s.opensearch == nil {
		s.handleGetScan(c)
		return
	}

	// Extract date from scan ID (format: inspector-YYYY-MM-DD)
	dateStr := strings.TrimPrefix(scanID, "inspector-")
	
	// Query for that specific day
	query := map[string]interface{}{
		"query": map[string]interface{}{
			"range": map[string]interface{}{
				"timestamp": map[string]interface{}{
					"gte": dateStr,
					"lt":  dateStr + "||+1d",
				},
			},
		},
		"size": 0,
		"aggs": map[string]interface{}{
			"by_severity": map[string]interface{}{
				"terms": map[string]interface{}{
					"field": "severity",
				},
			},
			"by_resource_type": map[string]interface{}{
				"terms": map[string]interface{}{
					"field": "resource_type",
				},
			},
			"unique_assets": map[string]interface{}{
				"cardinality": map[string]interface{}{
					"field": "resource_id",
				},
			},
			"total_findings": map[string]interface{}{
				"value_count": map[string]interface{}{
					"field": "id",
				},
			},
		},
	}

	result, err := s.executeOpenSearchQuery("siem-vulnerabilities", query)
	if err != nil {
		log.Printf("‚ö†Ô∏è Failed to get scan details: %v", err)
		s.handleGetScan(c)
		return
	}

	// Parse results
	scan := map[string]interface{}{
		"id":           scanID,
		"name":         fmt.Sprintf("Inspector Scan - %s", dateStr),
		"type":         "continuous",
		"status":       "completed",
		"started_at":   dateStr,
		"initiated_by": "AWS Inspector",
		"source":       "aws-inspector",
	}

	if aggs, ok := result["aggregations"].(map[string]interface{}); ok {
		// Severity breakdown
		severityBreakdown := map[string]int{}
		if bySev, ok := aggs["by_severity"].(map[string]interface{}); ok {
			if buckets, ok := bySev["buckets"].([]interface{}); ok {
				for _, b := range buckets {
					bucket := b.(map[string]interface{})
					key := bucket["key"].(string)
					count := int(bucket["doc_count"].(float64))
					severityBreakdown[key] = count
				}
			}
		}
		scan["severity_breakdown"] = severityBreakdown

		// Resource type breakdown
		resourceBreakdown := map[string]int{}
		if byRes, ok := aggs["by_resource_type"].(map[string]interface{}); ok {
			if buckets, ok := byRes["buckets"].([]interface{}); ok {
				for _, b := range buckets {
					bucket := b.(map[string]interface{})
					key := bucket["key"].(string)
					count := int(bucket["doc_count"].(float64))
					resourceBreakdown[key] = count
				}
			}
		}
		scan["resource_breakdown"] = resourceBreakdown

		// Total counts
		if ua, ok := aggs["unique_assets"].(map[string]interface{}); ok {
			scan["assets_scanned"] = int(ua["value"].(float64))
		}
		if tf, ok := aggs["total_findings"].(map[string]interface{}); ok {
			scan["vulnerabilities_found"] = int(tf["value"].(float64))
		}
	}

	c.JSON(http.StatusOK, scan)
}

// handleCreateScanReal triggers an on-demand scan (if supported)
func (s *APIServer) handleCreateScanReal(c *gin.Context) {
	// AWS Inspector v2 doesn't support on-demand scans in the same way
	// It does continuous scanning automatically
	// We can return information about how to trigger a rescan
	
	c.JSON(http.StatusOK, gin.H{
		"message": "AWS Inspector v2 performs continuous scanning automatically",
		"info":    "New resources are scanned automatically when detected. To force a rescan, you can: 1) Stop and start the EC2 instance, 2) Push a new image to ECR, 3) Update the Lambda function",
		"status":  "continuous_scanning_active",
		"documentation": "https://docs.aws.amazon.com/inspector/latest/user/scanning-resources.html",
	})
}

// executeOpenSearchQuery is a helper to execute queries
func (s *APIServer) executeOpenSearchQuery(index string, query map[string]interface{}) (map[string]interface{}, error) {
	queryJSON, err := json.Marshal(query)
	if err != nil {
		return nil, err
	}

	res, err := s.opensearch.Search(
		s.opensearch.Search.WithIndex(index),
		s.opensearch.Search.WithBody(strings.NewReader(string(queryJSON))),
	)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	if res.IsError() {
		return nil, fmt.Errorf("search error: %s", res.String())
	}

	var result map[string]interface{}
	if err := json.NewDecoder(res.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result, nil
}

