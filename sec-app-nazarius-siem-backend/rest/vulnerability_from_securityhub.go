package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/service/securityhub"
	"github.com/gin-gonic/gin"
	"github.com/opensearch-project/opensearch-go/v2/opensearchapi"
)

// VulnerabilityFromSecurityHub represents a vulnerability from Security Hub/Inspector
type VulnerabilityFromSecurityHub struct {
	ID                 string    `json:"id"`
	Title              string    `json:"title"`
	Description        string    `json:"description"`
	CVEID              string    `json:"cve_id"`
	CVSSScore          float64   `json:"cvss_score"`
	Severity           string    `json:"severity"`
	Status             string    `json:"status"`
	ResourceID         string    `json:"resource_id"`
	ResourceType       string    `json:"resource_type"`
	ResourceRegion     string    `json:"resource_region"`
	AffectedPackage    string    `json:"affected_package"`
	FixedVersion       string    `json:"fixed_version"`
	InstalledVersion   string    `json:"installed_version"`
	Remediation        string    `json:"remediation"`
	ExploitAvailable   bool      `json:"exploit_available"`
	NetworkReachable   bool      `json:"network_reachable"`
	FirstObservedAt    time.Time `json:"first_observed_at"`
	LastObservedAt     time.Time `json:"last_observed_at"`
	UpdatedAt          time.Time `json:"updated_at"`
	ProductName        string    `json:"product_name"`
	ProductARN         string    `json:"product_arn"`
	FindingARN         string    `json:"finding_arn"`
	GeneratorID        string    `json:"generator_id"`
	AwsAccountID       string    `json:"aws_account_id"`
	ComplianceStatus   string    `json:"compliance_status"`
	WorkflowStatus     string    `json:"workflow_status"`
	RecordState        string    `json:"record_state"`
	Source             string    `json:"source"`
	Timestamp          time.Time `json:"timestamp"`
}

// getVulnerabilitiesFromSecurityHub fetches Inspector findings from Security Hub
func (s *APIServer) getVulnerabilitiesFromSecurityHub() ([]VulnerabilityFromSecurityHub, error) {
	awsSess, err := getAWSSession()
	if err != nil {
		return nil, fmt.Errorf("failed to get AWS session: %v", err)
	}

	region := os.Getenv("AWS_REGION")
	if region == "" {
		region = "us-east-1"
	}

	shClient := securityhub.New(awsSess, aws.NewConfig().WithRegion(region))

	// Filter for Inspector findings specifically
	input := &securityhub.GetFindingsInput{
		MaxResults: aws.Int64(100),
		Filters: &securityhub.AwsSecurityFindingFilters{
			ProductName: []*securityhub.StringFilter{
				{Value: aws.String("Inspector"), Comparison: aws.String("EQUALS")},
			},
			RecordState: []*securityhub.StringFilter{
				{Value: aws.String("ACTIVE"), Comparison: aws.String("EQUALS")},
			},
		},
		SortCriteria: []*securityhub.SortCriterion{
			{
				Field:     aws.String("SeverityNormalized"),
				SortOrder: aws.String("desc"),
			},
		},
	}

	result, err := shClient.GetFindings(input)
	if err != nil {
		return nil, fmt.Errorf("failed to get Security Hub findings: %v", err)
	}

	var vulnerabilities []VulnerabilityFromSecurityHub

	for _, finding := range result.Findings {
		vuln := convertSecurityHubFindingToVulnerability(finding)
		if vuln != nil {
			vulnerabilities = append(vulnerabilities, *vuln)
		}
	}

	log.Printf("ðŸ“Š Fetched %d vulnerabilities from Security Hub (Inspector)", len(vulnerabilities))
	return vulnerabilities, nil
}

// convertSecurityHubFindingToVulnerability converts a Security Hub finding to vulnerability format
func convertSecurityHubFindingToVulnerability(finding *securityhub.AwsSecurityFinding) *VulnerabilityFromSecurityHub {
	if finding == nil {
		return nil
	}

	vuln := &VulnerabilityFromSecurityHub{
		ID:             sanitizeID(aws.StringValue(finding.Id)),
		Title:          aws.StringValue(finding.Title),
		Description:    aws.StringValue(finding.Description),
		ProductName:    aws.StringValue(finding.ProductName),
		ProductARN:     aws.StringValue(finding.ProductArn),
		FindingARN:     aws.StringValue(finding.Id),
		GeneratorID:    aws.StringValue(finding.GeneratorId),
		AwsAccountID:   aws.StringValue(finding.AwsAccountId),
		Source:         "security-hub-inspector",
		Timestamp:      time.Now(),
	}

	// Extract severity
	if finding.Severity != nil {
		vuln.Severity = strings.ToUpper(aws.StringValue(finding.Severity.Label))
		if finding.Severity.Normalized != nil {
			vuln.CVSSScore = float64(*finding.Severity.Normalized) / 10.0 // Normalize to 0-10 scale
		}
	}

	// Extract resource info
	if len(finding.Resources) > 0 {
		resource := finding.Resources[0]
		vuln.ResourceID = aws.StringValue(resource.Id)
		vuln.ResourceType = aws.StringValue(resource.Type)
		vuln.ResourceRegion = aws.StringValue(resource.Region)
	}

	// Extract CVE from vulnerabilities field
	if finding.Vulnerabilities != nil && len(finding.Vulnerabilities) > 0 {
		vulnDetails := finding.Vulnerabilities[0]
		vuln.CVEID = aws.StringValue(vulnDetails.Id)
		
		// Extract package info
		if vulnDetails.VulnerablePackages != nil && len(vulnDetails.VulnerablePackages) > 0 {
			pkg := vulnDetails.VulnerablePackages[0]
			vuln.AffectedPackage = aws.StringValue(pkg.Name)
			vuln.InstalledVersion = aws.StringValue(pkg.Version)
			vuln.FixedVersion = aws.StringValue(pkg.FixedInVersion)
		}

		// Extract CVSS
		if vulnDetails.Cvss != nil && len(vulnDetails.Cvss) > 0 {
			for _, cvss := range vulnDetails.Cvss {
				if cvss.BaseScore != nil {
					vuln.CVSSScore = *cvss.BaseScore
					break
				}
			}
		}

		// Check exploit availability
		if vulnDetails.ExploitAvailable != nil {
			vuln.ExploitAvailable = strings.ToLower(aws.StringValue(vulnDetails.ExploitAvailable)) == "yes"
		}
	}

	// Extract remediation
	if finding.Remediation != nil && finding.Remediation.Recommendation != nil {
		vuln.Remediation = aws.StringValue(finding.Remediation.Recommendation.Text)
	}

	// Extract workflow status
	if finding.Workflow != nil {
		vuln.WorkflowStatus = aws.StringValue(finding.Workflow.Status)
	}

	// Extract record state
	vuln.RecordState = aws.StringValue(finding.RecordState)

	// Extract compliance status
	if finding.Compliance != nil {
		vuln.ComplianceStatus = aws.StringValue(finding.Compliance.Status)
	}

	// Map workflow status to our status
	switch vuln.WorkflowStatus {
	case "NEW":
		vuln.Status = "OPEN"
	case "NOTIFIED":
		vuln.Status = "IN_PROGRESS"
	case "RESOLVED":
		vuln.Status = "FIXED"
	case "SUPPRESSED":
		vuln.Status = "SUPPRESSED"
	default:
		vuln.Status = "OPEN"
	}

	// Parse timestamps
	if finding.FirstObservedAt != nil {
		if t, err := time.Parse(time.RFC3339, *finding.FirstObservedAt); err == nil {
			vuln.FirstObservedAt = t
		}
	}
	if finding.LastObservedAt != nil {
		if t, err := time.Parse(time.RFC3339, *finding.LastObservedAt); err == nil {
			vuln.LastObservedAt = t
		}
	}
	if finding.UpdatedAt != nil {
		if t, err := time.Parse(time.RFC3339, *finding.UpdatedAt); err == nil {
			vuln.UpdatedAt = t
		}
	}

	return vuln
}

// indexVulnerabilitiesFromSecurityHub indexes vulnerabilities from Security Hub to OpenSearch
func (s *APIServer) indexVulnerabilitiesFromSecurityHub(vulns []VulnerabilityFromSecurityHub) error {
	if s.opensearch == nil {
		return fmt.Errorf("OpenSearch client not initialized")
	}

	for _, vuln := range vulns {
		vulnJSON, err := json.Marshal(vuln)
		if err != nil {
			log.Printf("âš ï¸ Failed to marshal vulnerability: %v", err)
			continue
		}

		req := opensearchapi.IndexRequest{
			Index:      "siem-vulnerabilities",
			DocumentID: vuln.ID,
			Body:       strings.NewReader(string(vulnJSON)),
			Refresh:    "true",
		}

		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		res, err := req.Do(ctx, s.opensearch)
		cancel()

		if err != nil {
			log.Printf("âš ï¸ Failed to index vulnerability %s: %v", vuln.ID, err)
			continue
		}
		res.Body.Close()
	}

	log.Printf("âœ… Indexed %d vulnerabilities from Security Hub", len(vulns))
	return nil
}

// handleSyncVulnerabilitiesFromSecurityHub syncs vulnerabilities from Security Hub
func (s *APIServer) handleSyncVulnerabilitiesFromSecurityHub(c *gin.Context) {
	go func() {
		log.Println("ðŸ”„ Starting vulnerability sync from Security Hub...")

		vulns, err := s.getVulnerabilitiesFromSecurityHub()
		if err != nil {
			log.Printf("âŒ Failed to get vulnerabilities from Security Hub: %v", err)
			return
		}

		if len(vulns) == 0 {
			log.Println("â„¹ï¸ No vulnerabilities found in Security Hub")
			return
		}

		if err := s.indexVulnerabilitiesFromSecurityHub(vulns); err != nil {
			log.Printf("âŒ Failed to index vulnerabilities: %v", err)
			return
		}

		log.Printf("âœ… Synced %d vulnerabilities from Security Hub to OpenSearch", len(vulns))
	}()

	c.JSON(http.StatusOK, gin.H{
		"message": "SincronizaÃ§Ã£o de vulnerabilidades do Security Hub iniciada",
		"note":    "Verifique os logs para acompanhar o progresso",
	})
}

// handleGetVulnerabilitiesFromSecurityHub returns vulnerabilities directly from Security Hub
func (s *APIServer) handleGetVulnerabilitiesFromSecurityHub(c *gin.Context) {
	vulns, err := s.getVulnerabilitiesFromSecurityHub()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{
			"error":   "Falha ao buscar vulnerabilidades do Security Hub",
			"details": err.Error(),
		})
		return
	}

	// Calculate stats
	stats := map[string]int{
		"total":    len(vulns),
		"critical": 0,
		"high":     0,
		"medium":   0,
		"low":      0,
	}

	for _, v := range vulns {
		switch v.Severity {
		case "CRITICAL":
			stats["critical"]++
		case "HIGH":
			stats["high"]++
		case "MEDIUM":
			stats["medium"]++
		case "LOW":
			stats["low"]++
		}
	}

	c.JSON(http.StatusOK, gin.H{
		"vulnerabilities": vulns,
		"stats":           stats,
		"total":           len(vulns),
		"source":          "security-hub-inspector",
		"fetched_at":      time.Now(),
	})
}

// StartSecurityHubVulnerabilityIndexer starts periodic indexing of vulnerabilities from Security Hub
func (s *APIServer) StartSecurityHubVulnerabilityIndexer(intervalMinutes int) {
	go func() {
		log.Printf("ðŸš€ Starting Security Hub Vulnerability Indexer (interval: %d minutes)", intervalMinutes)

		// Initial sync
		vulns, err := s.getVulnerabilitiesFromSecurityHub()
		if err != nil {
			log.Printf("âŒ Initial vulnerability sync failed: %v", err)
		} else if len(vulns) > 0 {
			s.indexVulnerabilitiesFromSecurityHub(vulns)
		}

		// Periodic sync
		ticker := time.NewTicker(time.Duration(intervalMinutes) * time.Minute)
		defer ticker.Stop()

		for range ticker.C {
			vulns, err := s.getVulnerabilitiesFromSecurityHub()
			if err != nil {
				log.Printf("âŒ Periodic vulnerability sync failed: %v", err)
				continue
			}

			if len(vulns) > 0 {
				s.indexVulnerabilitiesFromSecurityHub(vulns)
			}
		}
	}()
}

