package main

import (
	"encoding/json"
	"net/http"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
)

// ============================================================================
// VULNERABILITY STATUS MANAGEMENT
// ============================================================================

// handleUpdateVulnerabilityStatus atualiza o status de uma vulnerabilidade
func (s *APIServer) handleUpdateVulnerabilityStatus(c *gin.Context) {
	vulnID := c.Param("id")

	var req struct {
		Status  string `json:"status" binding:"required"` // ACTIVE, ACKNOWLEDGED, IN_REMEDIATION, RISK_ACCEPTED, FALSE_POSITIVE, RESOLVED
		Reason  string `json:"reason"`
		Comment string `json:"comment"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if s.opensearch == nil {
		c.JSON(http.StatusNotImplemented, gin.H{"error": "OpenSearch not available"})
		return
	}

	// Validar status
	validStatuses := map[string]bool{
		"ACTIVE":         true,
		"ACKNOWLEDGED":   true,
		"IN_REMEDIATION": true,
		"RISK_ACCEPTED":  true,
		"FALSE_POSITIVE": true,
		"RESOLVED":       true,
	}

	statusUpper := strings.ToUpper(req.Status)
	if !validStatuses[statusUpper] {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid status. Valid values: ACTIVE, ACKNOWLEDGED, IN_REMEDIATION, RISK_ACCEPTED, FALSE_POSITIVE, RESOLVED"})
		return
	}

	// Atualizar no OpenSearch
	updateDoc := map[string]interface{}{
		"doc": map[string]interface{}{
			"status":     statusUpper,
			"updated_at": time.Now().Format(time.RFC3339),
			"updated_by": "admin", // TODO: Get from JWT token
		},
	}

	if req.Reason != "" {
		updateDoc["doc"].(map[string]interface{})["status_reason"] = req.Reason
	}
	if req.Comment != "" {
		updateDoc["doc"].(map[string]interface{})["status_comment"] = req.Comment
	}

	// Adicionar timestamp espec√≠fico baseado no status
	switch statusUpper {
	case "ACKNOWLEDGED":
		updateDoc["doc"].(map[string]interface{})["acknowledged_at"] = time.Now().Format(time.RFC3339)
	case "IN_REMEDIATION":
		updateDoc["doc"].(map[string]interface{})["remediation_started_at"] = time.Now().Format(time.RFC3339)
	case "RISK_ACCEPTED":
		updateDoc["doc"].(map[string]interface{})["risk_accepted_at"] = time.Now().Format(time.RFC3339)
	case "RESOLVED":
		updateDoc["doc"].(map[string]interface{})["resolved_at"] = time.Now().Format(time.RFC3339)
	case "FALSE_POSITIVE":
		updateDoc["doc"].(map[string]interface{})["false_positive_at"] = time.Now().Format(time.RFC3339)
	}

	updateJSON, _ := json.Marshal(updateDoc)

	res, err := s.opensearch.Update(
		"siem-vulnerabilities",
		vulnID,
		strings.NewReader(string(updateJSON)),
		s.opensearch.Update.WithRefresh("true"),
	)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update vulnerability"})
		return
	}
	defer res.Body.Close()

	if res.IsError() {
		c.JSON(http.StatusNotFound, gin.H{"error": "Vulnerability not found"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"message": "Vulnerability status updated successfully",
	})
}

